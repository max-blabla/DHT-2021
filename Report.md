# Report

额，其实没啥好写的。

第一周学习Go语言，第二周开始自起炉灶，然后发现炉灶炸了。

第三周才写完chord协议。

Chord协议基本的部分就略过不提了。

主要讲讲路由表(finger表)和后继表的维护。

路由表由后继表推出和后继的后继表等推出，每轮只维护后继中一个表项，然后休息$250ms$。

后继表由直接后继与直接后继的后继表来维护，当发现直接后继失效后，则找到第一个有效的后继，然后休息$250ms$。

除了固定周期的维护，当需要查询路由表和后继表时发现对应节点失效后，会向相关节点发送请求。让对方额外进行表的维护，并将维护后的表返还，直到表单有效。

那么$ForceQuit$：只要更新足够快，它就对我没有影响。

PS：由于写的比较粗糙，只以通过为目的，所以测试时可能要跑比较久。如果发生了由于并发导致的神秘的数组越界，可以试着多跑几组，目前本地只有一次出现这种情况，并且被修好了。又如果发生了内存不足或者是无法跑出的情况，只能在CR当面进行演示了

